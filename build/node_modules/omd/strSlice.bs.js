// Generated by Melange

import * as Caml from "melange.js/caml.bs.js";
import * as Caml_string from "melange.js/caml_string.bs.js";
import * as Curry from "melange.js/curry.bs.js";
import * as Stdlib from "melange/stdlib.bs.js";
import * as Stdlib__Buffer from "melange/buffer.bs.js";
import * as Stdlib__Format from "melange/format.bs.js";
import * as Stdlib__Lexing from "melange/lexing.bs.js";
import * as Stdlib__Option from "melange/option.bs.js";
import * as Stdlib__String from "melange/string.bs.js";

function of_string(offOpt, base) {
  const off = offOpt !== undefined ? offOpt : 0;
  return {
          base: base,
          off: off,
          len: base.length - off | 0
        };
}

function to_string(param) {
  return Stdlib__String.sub(param.base, param.off, param.len);
}

function print(ppf, s) {
  Curry._1(Stdlib__Format.fprintf(ppf)(/* Format */{
            _0: {
              TAG: /* Caml_string */3,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%S"
          }), to_string(s));
}

function get_offset(param) {
  return param.off;
}

function length(param) {
  return param.len;
}

function is_empty(s) {
  return length(s) === 0;
}

function offset(n, param) {
  if (n < 0) {
    Stdlib.invalid_arg("offset");
  }
  let _n = n;
  let _base = param.base;
  let _off = param.off;
  let _len = param.len;
  while(true) {
    const len = _len;
    const off = _off;
    const base = _base;
    const n$1 = _n;
    if (n$1 === 0 || len === 0) {
      return {
              base: base,
              off: off,
              len: len
            };
    }
    const match = Caml_string.get(base, off);
    if (match !== 9) {
      _len = len - 1 | 0;
      _off = off + 1 | 0;
      _n = n$1 - 1 | 0;
      continue ;
    }
    const ts = (((off + 4 | 0) / 4 | 0) << 2) - off | 0;
    const b = Stdlib__Buffer.create(len);
    Stdlib__Buffer.add_substring(b, base, 0, off);
    for(let _for = 1; _for <= ts; ++_for){
      Stdlib__Buffer.add_char(b, /* ' ' */32);
    }
    Stdlib__Buffer.add_substring(b, base, off + 1 | 0, len - 1 | 0);
    _len = (len + ts | 0) - 1 | 0;
    _base = Stdlib__Buffer.contents(b);
    continue ;
  };
}

function lexbuf(s) {
  return Stdlib__Lexing.from_string(undefined, to_string(s));
}

function contains(s1, param) {
  const len = param.len;
  const base = param.base;
  let _off = param.off;
  while(true) {
    const off = _off;
    if ((off + s1.length | 0) > len) {
      return false;
    }
    if (s1 === Stdlib__String.sub(base, off, s1.length)) {
      return true;
    }
    _off = off + 1 | 0;
    continue ;
  };
}

function head(param) {
  if (param.len !== 0) {
    return Caml_string.get(param.base, param.off);
  }
  
}

function last(param) {
  if (param.len !== 0) {
    return Caml_string.get(param.base, (param.off + param.len | 0) - 1 | 0);
  }
  
}

function tail(s) {
  if (s.len !== 0) {
    return {
            base: s.base,
            off: s.off + 1 | 0,
            len: s.len - 1 | 0
          };
  } else {
    return s;
  }
}

function uncons(s) {
  return Stdlib__Option.map((function (hd) {
                return [
                        hd,
                        tail(s)
                      ];
              }), head(s));
}

function take(n, s) {
  if (n < 0) {
    Stdlib.invalid_arg("take");
  }
  const loop = function (n, s) {
    if (n === 0 || length(s) === 0) {
      return /* [] */0;
    }
    const c = head(s);
    if (c !== undefined) {
      return {
              hd: c,
              tl: loop(n - 1 | 0, tail(s))
            };
    } else {
      return /* [] */0;
    }
  };
  return loop(n, s);
}

function take_prefix(n, s) {
  if (n < 0) {
    Stdlib.invalid_arg("take_prefix");
  }
  const len = n < s.len ? n : s.len;
  return {
          base: s.base,
          off: s.off,
          len: len
        };
}

function drop(n, s) {
  if (n < 0) {
    Stdlib.invalid_arg("drop");
  }
  const len = Caml.caml_int_max(s.len - n | 0, 0);
  const off = Caml.caml_int_min(s.off + n | 0, s.base.length);
  return {
          base: s.base,
          off: off,
          len: len
        };
}

function drop_last(s) {
  if (s.len !== 0) {
    return {
            base: s.base,
            off: s.off,
            len: s.len - 1 | 0
          };
  } else {
    return s;
  }
}

function drop_while(f, _s) {
  while(true) {
    const s = _s;
    const match = uncons(s);
    if (match === undefined) {
      return s;
    }
    if (!Curry._1(f, match[0])) {
      return s;
    }
    _s = match[1];
    continue ;
  };
}

function drop_last_while(f, _s) {
  while(true) {
    const s = _s;
    const l = last(s);
    if (l === undefined) {
      return s;
    }
    if (!Curry._1(f, l)) {
      return s;
    }
    _s = drop_last(s);
    continue ;
  };
}

function index(f, s) {
  const len = length(s);
  const rest = drop_while((function (c) {
          return !Curry._1(f, c);
        }), s);
  const idx = len - length(rest) | 0;
  if (idx === len) {
    return ;
  } else {
    return idx;
  }
}

function split_at(f, s) {
  const idx = index(f, s);
  if (idx !== undefined) {
    return [
            {
              base: s.base,
              off: s.off,
              len: idx
            },
            offset(idx, s)
          ];
  } else {
    return [
            s,
            offset(length(s), s)
          ];
  }
}

function index_unescaped(sep, s) {
  let _idx = s.off;
  let _state = "normal";
  while(true) {
    const state = _state;
    const idx = _idx;
    if (idx === (s.off + s.len | 0)) {
      return ;
    }
    const match = Caml_string.get(s.base, idx);
    if (typeof state === "string") {
      if (state === "normal") {
        if (match !== 92) {
          if (match !== 96) {
            if (match === sep) {
              return idx - s.off | 0;
            }
            _state = "normal";
            _idx = idx + 1 | 0;
            continue ;
          }
          _state = {
            NAME: "verbatim_open",
            VAL: 1
          };
          _idx = idx + 1 | 0;
          continue ;
        }
        _state = "escape";
        _idx = idx + 1 | 0;
        continue ;
      }
      _state = "normal";
      _idx = idx + 1 | 0;
      continue ;
    }
    const variant = state.NAME;
    if (variant === "within_verbatim") {
      const n = state.VAL;
      if (n === 1 && match === 96) {
        _state = "normal";
        _idx = idx + 1 | 0;
        continue ;
      }
      if (match !== 96) {
        _state = {
          NAME: "within_verbatim",
          VAL: n
        };
        _idx = idx + 1 | 0;
        continue ;
      }
      _state = {
        NAME: "verbatim_close",
        VAL: [
          n,
          n - 1 | 0
        ]
      };
      _idx = idx + 1 | 0;
      continue ;
    }
    if (variant === "verbatim_close") {
      const match$1 = state.VAL;
      const n$1 = match$1[0];
      const k = match$1[1];
      if (k === 1 && match === 96) {
        _state = "normal";
        _idx = idx + 1 | 0;
        continue ;
      }
      if (match !== 96) {
        _state = {
          NAME: "within_verbatim",
          VAL: n$1
        };
        _idx = idx + 1 | 0;
        continue ;
      }
      _state = {
        NAME: "verbatim_close",
        VAL: [
          n$1,
          k - 1 | 0
        ]
      };
      _idx = idx + 1 | 0;
      continue ;
    }
    const n$2 = state.VAL;
    if (match !== 96) {
      _state = {
        NAME: "within_verbatim",
        VAL: n$2
      };
      _idx = idx + 1 | 0;
      continue ;
    }
    _state = {
      NAME: "verbatim_open",
      VAL: n$2 + 1 | 0
    };
    _idx = idx + 1 | 0;
    continue ;
  };
}

function exists(f, s) {
  let _i = 0;
  while(true) {
    const i = _i;
    if (i >= s.len) {
      return false;
    }
    if (Curry._1(f, Caml_string.get(s.base, s.off + i | 0))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(f, s) {
  return !exists((function (c) {
                return !Curry._1(f, c);
              }), s);
}

function sub(len, s) {
  if (len > s.len) {
    Stdlib.invalid_arg("sub");
  }
  return {
          base: s.base,
          off: s.off,
          len: len
        };
}

function fold_left(f, init, s) {
  let _acc = init;
  let _rest = s;
  while(true) {
    const rest = _rest;
    const acc = _acc;
    const match = uncons(rest);
    if (match === undefined) {
      return acc;
    }
    _rest = match[1];
    _acc = Curry._2(f, match[0], acc);
    continue ;
  };
}

function trim(s) {
  const is_whitespace = function (param) {
    if (param >= 14) {
      return param === 32;
    } else {
      return param >= 9;
    }
  };
  return drop_while(is_whitespace, drop_last_while(is_whitespace, s));
}

export {
  of_string ,
  to_string ,
  offset ,
  lexbuf ,
  contains ,
  length ,
  index ,
  index_unescaped ,
  print ,
  head ,
  tail ,
  uncons ,
  last ,
  drop_last ,
  take ,
  take_prefix ,
  drop ,
  drop_while ,
  drop_last_while ,
  split_at ,
  fold_left ,
  for_all ,
  exists ,
  is_empty ,
  get_offset ,
  sub ,
  trim ,
}
/* Stdlib__Format Not a pure module */
