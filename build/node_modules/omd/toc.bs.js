// Generated by Melange

import * as Caml_option from "melange.js/caml_option.bs.js";
import * as Stdlib from "melange/stdlib.bs.js";
import * as Stdlib__List from "melange/list.bs.js";
import * as Stdlib__String from "melange/string.bs.js";

function remove_links(inline) {
  switch (inline.TAG | 0) {
    case /* Concat */0 :
        return {
                TAG: /* Concat */0,
                _0: inline._0,
                _1: Stdlib__List.map(remove_links, inline._1)
              };
    case /* Emph */2 :
    case /* Strong */3 :
        return {
                TAG: /* Emph */2,
                _0: inline._0,
                _1: remove_links(inline._1)
              };
    case /* Link */7 :
        return inline._1.label;
    case /* Image */8 :
        const link = inline._1;
        return {
                TAG: /* Image */8,
                _0: inline._0,
                _1: {
                  label: remove_links(link.label),
                  destination: link.destination,
                  title: link.title
                }
              };
    default:
      return inline;
  }
}

function headers(remove_linksOpt, doc) {
  const remove_links$1 = remove_linksOpt !== undefined ? remove_linksOpt : false;
  const headers$1 = {
    contents: /* [] */0
  };
  const loop = function (blocks) {
    Stdlib__List.iter((function (param) {
            switch (param.TAG | 0) {
              case /* List */1 :
                  return Stdlib__List.iter(loop, param._3);
              case /* Blockquote */2 :
                  return loop(param._1);
              case /* Heading */4 :
                  const inline = param._2;
                  const inline$1 = remove_links$1 ? remove_links(inline) : inline;
                  headers$1.contents = {
                    hd: [
                      param._0,
                      param._1,
                      inline$1
                    ],
                    tl: headers$1.contents
                  };
                  return ;
              default:
                return ;
            }
          }), blocks);
  };
  loop(doc);
  return Stdlib__List.rev(headers$1.contents);
}

function find_start(_headers, _level, _number, _subsections) {
  while(true) {
    const subsections = _subsections;
    const number = _number;
    const level = _level;
    const headers = _headers;
    if (!headers) {
      return /* [] */0;
    }
    const match = headers.hd;
    if (match[1] > level) {
      if (number === 0) {
        if (!subsections) {
          return headers;
        }
        _subsections = subsections.tl;
        _number = subsections.hd;
        _level = level + 1 | 0;
        continue ;
      }
      _headers = headers.tl;
      continue ;
    }
    if (match[1] !== level) {
      return /* [] */0;
    }
    const tl = headers.tl;
    if (number <= 1) {
      if (!subsections) {
        return tl;
      }
      _subsections = subsections.tl;
      _number = subsections.hd;
      _level = level + 1 | 0;
      _headers = tl;
      continue ;
    }
    _number = number - 1 | 0;
    _headers = tl;
    continue ;
  };
}

function unordered_list(items) {
  return {
          TAG: /* List */1,
          _0: /* [] */0,
          _1: {
            TAG: /* Bullet */1,
            _0: /* '*' */42
          },
          _2: /* Tight */1,
          _3: items
        };
}

function find_id(attributes) {
  return Stdlib__List.find_map((function (param) {
                if (Stdlib__String.equal("id", param[0])) {
                  return Caml_option.some(param[1]);
                }
                
              }), attributes);
}

function link(attributes, label) {
  const id = find_id(attributes);
  const inline = id !== undefined ? ({
        TAG: /* Link */7,
        _0: /* [] */0,
        _1: {
          label: label,
          destination: "#" + id,
          title: undefined
        }
      }) : label;
  return {
          TAG: /* Paragraph */0,
          _0: /* [] */0,
          _1: inline
        };
}

function make_toc(_headers, min_level, max_level) {
  while(true) {
    const headers = _headers;
    if (min_level > max_level) {
      return [
              /* [] */0,
              headers
            ];
    }
    if (!headers) {
      return [
              /* [] */0,
              /* [] */0
            ];
    }
    const match = headers.hd;
    const attr = match[0];
    const level = match[1];
    if (level < min_level) {
      return [
              /* [] */0,
              headers
            ];
    }
    if (level > max_level) {
      _headers = headers.tl;
      continue ;
    }
    if (match[1] === min_level) {
      const t = match[2];
      const match$1 = make_toc(headers.tl, min_level + 1 | 0, max_level);
      const sub_toc = match$1[0];
      const toc_entry = sub_toc ? ({
            hd: link(attr, t),
            tl: {
              hd: unordered_list(sub_toc),
              tl: /* [] */0
            }
          }) : ({
            hd: link(attr, t),
            tl: /* [] */0
          });
      const match$2 = make_toc(match$1[1], min_level, max_level);
      return [
              {
                hd: toc_entry,
                tl: match$2[0]
              },
              match$2[1]
            ];
    }
    const match$3 = make_toc(headers, min_level + 1 | 0, max_level);
    const match$4 = make_toc(match$3[1], min_level, max_level);
    return [
            {
              hd: {
                hd: unordered_list(match$3[0]),
                tl: /* [] */0
              },
              tl: match$4[0]
            },
            match$4[1]
          ];
  };
}

function toc(startOpt, depthOpt, doc) {
  const start = startOpt !== undefined ? startOpt : /* [] */0;
  const depth = depthOpt !== undefined ? depthOpt : 2;
  if (depth < 1) {
    Stdlib.invalid_arg("Omd.toc: ~depth must be >= 1");
  }
  const headers$1 = headers(true, doc);
  let headers$2;
  if (start) {
    const number = start.hd;
    headers$2 = number < 0 ? Stdlib.invalid_arg("Omd.toc: level 1 start must be >= 0") : find_start(headers$1, 1, number, start.tl);
  } else {
    headers$2 = headers$1;
  }
  const len = Stdlib__List.length(start);
  const match = make_toc(headers$2, len + 1 | 0, len + depth | 0);
  const toc$1 = match[0];
  if (toc$1) {
    return {
            hd: unordered_list(toc$1),
            tl: /* [] */0
          };
  } else {
    return /* [] */0;
  }
}

export {
  remove_links ,
  headers ,
  find_start ,
  unordered_list ,
  find_id ,
  link ,
  make_toc ,
  toc ,
}
/* No side effect */
